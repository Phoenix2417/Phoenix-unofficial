const { existsSync, readFileSync, writeFileSync, mkdirSync } = require("fs-extra");
const path = require("path");

const CACHE_DIR = path.join(__dirname, "cache");
const rentPath = path.join(CACHE_DIR, "rent.json");
const validKeyPath = path.join(CACHE_DIR, "validKeys.json");
const adminIDs = ["100027248830437"];
const ADMIN_BOX_ID = "9338323819548687"; // ID c·ªßa box admin

function ensureCache() {
  if (!existsSync(CACHE_DIR)) mkdirSync(CACHE_DIR, { recursive: true });
}
function loadJSON(filePath, defaultData) {
  ensureCache();
  if (!existsSync(filePath)) {
    writeFileSync(filePath, JSON.stringify(defaultData, null, 4));
    return defaultData;
  }
  try {
    return JSON.parse(readFileSync(filePath, "utf-8"));
  } catch (err) {
    return defaultData;
  }
}
function saveJSON(filePath, data) {
  ensureCache();
  writeFileSync(filePath, JSON.stringify(data, null, 4));
}
function loadValidKeys() {
  return loadJSON(validKeyPath, []);
}
function saveValidKeys(keys) {
  saveJSON(validKeyPath, keys);
}
function generateKey(existingKeys = []) {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let randomCode, key;
  do {
    randomCode = '';
    for (let i = 0; i < 5; i++) randomCode += chars.charAt(Math.floor(Math.random() * chars.length));
    key = `phoenix#${randomCode}`;
  } while (existingKeys.includes(key));
  return key;
}

module.exports.config = {
  name: "rent",
  version: "1.0.0",
  hasPermssion: 0,
  credits: "Ho√†ng Nguy·ªÖn",
  description: "Qu·∫£n l√Ω c√°c nh√≥m thu√™ bot",
  commandCategory: "Admin",
  usages: "[add/del/list/info/genkey/listkeys/giahan] [threadID] [key] [ng√†y h·∫øt h·∫°n (optional)]",
  cooldowns: 5
};

module.exports.languages = {
  vi: {
    invalidCommand: "L·ªánh kh√¥ng h·ª£p l·ªá. S·ª≠ d·ª•ng: rent add/del/list/info/genkey/listkeys/giahan [threadID] [key] [ng√†y h·∫øt h·∫°n]",
    addSuccess: "ƒê√£ th√™m nh√≥m %1 v√†o danh s√°ch thu√™ bot v·ªõi key %2 (h·∫øt h·∫°n: %3)",
    addFailed: "Th√™m nh√≥m th·∫•t b·∫°i, nh√≥m n√†y ƒë√£ t·ªìn t·∫°i trong danh s√°ch thu√™",
    delSuccess: "ƒê√£ x√≥a nh√≥m %1 kh·ªèi danh s√°ch thu√™ bot",
    delFailed: "X√≥a nh√≥m th·∫•t b·∫°i, nh√≥m kh√¥ng t·ªìn t·∫°i trong danh s√°ch thu√™",
    listEmpty: "Kh√¥ng c√≥ nh√≥m n√†o ƒëang thu√™ bot",
    listHeader: "‚ö°Ô∏è Danh s√°ch c√°c nh√≥m ƒëang thu√™ bot ‚ö°Ô∏è\n",
    listItem: "%1. ID: %2\n    Key: %3\n    Ng√†y h·∫øt h·∫°n: %4\n",
    keyUpdated: "ƒê√£ c·∫≠p nh·∫≠t key cho nh√≥m %1 th√†nh %2",
    keyUpdateFailed: "C·∫≠p nh·∫≠t key th·∫•t b·∫°i, nh√≥m kh√¥ng t·ªìn t·∫°i trong danh s√°ch thu√™",
    keyActivated: "‚úÖ Key %1 ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t th√†nh c√¥ng!\nüìÖ Th·ªùi h·∫°n: %2 (30 ng√†y)",
    keyExtended: "‚úÖ Key %1 ƒë√£ gia h·∫°n th√†nh c√¥ng!\nüìÖ Th·ªùi h·∫°n m·ªõi: %2 (th√™m 30 ng√†y)",
    keyInvalid: "‚ùå Key kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng!",
    noPermission: "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y",
    rentInfo: "üìå TH√îNG TIN THU√ä BOT üìå\n\nüí∞ Gi√° thu√™: 25.000ƒë\n‚è±Ô∏è Th·ªùi h·∫°n: 1 th√°ng (30 ng√†y)\n\nüìû Li√™n h·ªá Admin ƒë·ªÉ thu√™ bot:\nFacebook: https://www.facebook.com/Phoenix.2417\n\n‚ö†Ô∏è L∆∞u √Ω: Bot s·∫Ω ch·ªâ ho·∫°t ƒë·ªông khi nh√≥m ƒë√£ ƒë∆∞·ª£c thu√™ v√† c√≤n th·ªùi h·∫°n s·ª≠ d·ª•ng.",
    notifyRenewed: "üîî Nh√≥m n√†y v·ª´a ƒë∆∞·ª£c gia h·∫°n th·ªùi gian s·ª≠ d·ª•ng bot th√†nh c√¥ng!\nüïí H·∫°n m·ªõi: %1",
    notifyActivated: "üéâ Nh√≥m n√†y ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t s·ª≠ d·ª•ng bot!\nüìÖ H·∫°n s·ª≠ d·ª•ng: %1",
    keyGenerated: "üîë Key m·ªõi ƒë√£ ƒë∆∞·ª£c t·∫°o: %1\n\nüìå H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng:\n1. G·ª≠i key n√†y v√†o nh√≥m chat b·∫°n mu·ªën thu√™ bot\n2. Bot s·∫Ω t·ª± ƒë·ªông k√≠ch ho·∫°t ho·∫∑c gia h·∫°n d·ªãch v·ª•\n\n‚è≥ Key c√≥ hi·ªáu l·ª±c trong v√≤ng 30 ng√†y",
    keySent: "‚úÖ ƒê√£ g·ª≠i key thu√™ bot ƒë·∫øn b·∫°n qua tin nh·∫Øn ri√™ng. Vui l√≤ng ki·ªÉm tra tin nh·∫Øn ch·ªù ho·∫∑c h·ªôp th∆∞ ƒë·∫øn!",
    extendRequestSent: "üì© ƒê√£ g·ª≠i y√™u c·∫ßu gia h·∫°n key %1 ƒë·∫øn admin. Vui l√≤ng ch·ªù ph·∫£n h·ªìi!",
    extendRequestReceived: "üîî Y√äU C·∫¶U GIA H·∫†N M·ªöI\n\nüë§ Ng∆∞·ªùi g·ª≠i: %1\nüìå Key: %2\nüè† Nh√≥m: %3\n\nVui l√≤ng x·ª≠ l√Ω y√™u c·∫ßu n√†y b·∫±ng c√°ch s·ª≠ d·ª•ng l·ªánh: rent add [threadID] [key] [ng√†y h·∫øt h·∫°n]"
  }
};

module.exports.onLoad = () => {
  loadJSON(rentPath, { groups: [] });
  loadJSON(validKeyPath, []);
};

module.exports.run = async function ({ api, event, args, getText, permission }) {
  const command = args[0]?.toLowerCase() || "info";
  const senderID = event.senderID;
  const threadID = event.threadID;
  const rentData = loadJSON(rentPath, { groups: [] });
  let validKeys = loadValidKeys();
  const _getText = typeof getText === "function" ? getText : (key, ...args) => key;

  // Nh·∫≠p key tr·ª±c ti·∫øp ƒë·ªÉ k√≠ch ho·∫°t/gia h·∫°n
  if (!command.startsWith("/") && !["add", "del", "list", "info", "genkey", "listkeys", "giahan"].includes(command)) {
    const inputKey = event.body.trim();
    if (validKeys.includes(inputKey)) {
      const today = new Date();
      const newExpiryDate = new Date(today);
      newExpiryDate.setMonth(today.getMonth() + 1);
      const index = rentData.groups.findIndex(group => group.threadID === threadID);
      if (index !== -1) {
        const currentExpiry = new Date(rentData.groups[index].expiryDate);
        const extendedExpiry = new Date(currentExpiry);
        extendedExpiry.setMonth(extendedExpiry.getMonth() + 1);
        rentData.groups[index].expiryDate = extendedExpiry.toISOString();
        rentData.groups[index].key = inputKey;
        saveJSON(rentPath, rentData);
        validKeys = validKeys.filter(k => k !== inputKey);
        saveValidKeys(validKeys);
        return api.sendMessage(
          _getText("keyExtended", inputKey, extendedExpiry.toLocaleDateString("vi-VN")),
          threadID, event.messageID
        );
      } else {
        rentData.groups.push({
          threadID,
          key: inputKey,
          expiryDate: newExpiryDate.toISOString()
        });
        saveJSON(rentPath, rentData);
        validKeys = validKeys.filter(k => k !== inputKey);
        saveValidKeys(validKeys);
        return api.sendMessage(
          _getText("keyActivated", inputKey, newExpiryDate.toLocaleDateString("vi-VN")),
          threadID, event.messageID
        );
      }
    } else if (inputKey.length > 5 && inputKey.includes("#")) {
      return api.sendMessage(_getText("keyInvalid"), threadID, event.messageID);
    }
    return;
  }

  if (command === "info") {
    return api.sendMessage(_getText("rentInfo"), threadID, event.messageID);
  }

  const isAdmin = permission >= 2 || adminIDs.includes(senderID);
  if (!isAdmin && ["add", "del", "genkey", "listkeys"].includes(command)) {
    return api.sendMessage(_getText("noPermission"), threadID, event.messageID);
  }

  const today = new Date();
  const defaultExpiryDate = new Date(today.setMonth(today.getMonth() + 1));
  const targetThreadID = args[1];

  switch (command) {
    case "add": {
      if (!targetThreadID || !args[2]) return api.sendMessage(_getText("invalidCommand"), threadID, event.messageID);
      const key = args[2];
      let expiryDate = args[3] ? new Date(args[3]) : defaultExpiryDate;
      if (isNaN(expiryDate.getTime())) expiryDate = defaultExpiryDate;
      if (rentData.groups.find(g => g.threadID === targetThreadID)) {
        return api.sendMessage(_getText("addFailed"), threadID, event.messageID);
      }
      rentData.groups.push({ threadID: targetThreadID, key, expiryDate: expiryDate.toISOString() });
      saveJSON(rentPath, rentData);
      return api.sendMessage(
        _getText("addSuccess", targetThreadID, key, expiryDate.toLocaleDateString("vi-VN")),
        threadID, event.messageID
      );
    }
    case "del": {
      if (!targetThreadID) return api.sendMessage(_getText("invalidCommand"), threadID, event.messageID);
      const index = rentData.groups.findIndex(g => g.threadID === targetThreadID);
      if (index === -1) return api.sendMessage(_getText("delFailed"), threadID, event.messageID);
      rentData.groups.splice(index, 1);
      saveJSON(rentPath, rentData);
      return api.sendMessage(_getText("delSuccess", targetThreadID), threadID, event.messageID);
    }
    case "list": {
      if (rentData.groups.length === 0) return api.sendMessage(_getText("listEmpty"), threadID, event.messageID);
      let msg = _getText("listHeader");
      rentData.groups.forEach((g, i) => {
        msg += _getText("listItem", i + 1, g.threadID, g.key, new Date(g.expiryDate).toLocaleDateString("vi-VN"));
      });
      return api.sendMessage(msg, threadID, event.messageID);
    }
    case "genkey": {
      const newKey = generateKey(validKeys);
      validKeys.push(newKey);
      saveValidKeys(validKeys);
      
      // G·ª≠i key qua tin nh·∫Øn ri√™ng cho ng∆∞·ªùi d√πng
      try {
        await api.sendMessage(_getText("keyGenerated", newKey), senderID);
        return api.sendMessage(_getText("keySent"), threadID, event.messageID);
      } catch (e) {
        // N·∫øu kh√¥ng g·ª≠i ƒë∆∞·ª£c tin nh·∫Øn ri√™ng, g·ª≠i key trong nh√≥m
        return api.sendMessage(_getText("keyGenerated", newKey), threadID, event.messageID);
      }
    }
    case "listkeys": {
      if (validKeys.length === 0) return api.sendMessage("üìù Kh√¥ng c√≥ key n√†o c√≤n hi·ªáu l·ª±c.", threadID, event.messageID);
      return api.sendMessage("üîë DANH S√ÅCH KEY C√íN HI·ªÜU L·ª∞C üîë\n\n" + validKeys.map((k, i) => `${i + 1}. ${k}`).join("\n"), threadID, event.messageID);
    }
    case "giahan": {
      if (!args[1]) return api.sendMessage("Vui l√≤ng nh·∫≠p key c·∫ßn gia h·∫°n theo c√∫ ph√°p: rent giahan [key]", threadID, event.messageID);
      
      const keyToExtend = args[1];
      const groupInfo = rentData.groups.find(g => g.key === keyToExtend);
      
      if (!groupInfo) {
        return api.sendMessage("‚ùå Key kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng t·ªìn t·∫°i trong h·ªá th·ªëng!", threadID, event.messageID);
      }
      
      // G·ª≠i th√¥ng b√°o ƒë·∫øn box admin
      const senderInfo = await api.getUserInfo(senderID);
      const senderName = senderInfo[senderID]?.name || "Ng∆∞·ªùi d√πng ·∫©n danh";
      
      const requestMessage = _getText("extendRequestReceived", 
        senderName + " (ID: " + senderID + ")", 
        keyToExtend, 
        groupInfo.threadID
      );
      
      try {
        await api.sendMessage(requestMessage, ADMIN_BOX_ID);
        return api.sendMessage(_getText("extendRequestSent", keyToExtend), threadID, event.messageID);
      } catch (e) {
        return api.sendMessage("‚ùå ƒê√£ x·∫£y ra l·ªói khi g·ª≠i y√™u c·∫ßu gia h·∫°n. Vui l√≤ng th·ª≠ l·∫°i sau!", threadID, event.messageID);
      }
    }
    default:
      return api.sendMessage(_getText("invalidCommand"), threadID, event.messageID);
  }
};

module.exports.generateKey = function () {
  const validKeys = loadValidKeys();
  return generateKey(validKeys);
};

module.exports.checkRent = function (threadID) {
  if (!existsSync(rentPath)) return false;
  try {
    const rentData = JSON.parse(readFileSync(rentPath, "utf-8"));
    const group = rentData.groups.find(g => g.threadID === threadID);
    if (!group) return false;
    const now = new Date();
    const expiryDate = new Date(group.expiryDate);
    if (now > expiryDate) return false;
    return {
      isRented: true,
      key: group.key,
      expiryDate
    };
  } catch (err) {
    return false;
  }
};